{"version":3,"sources":["hooks.tsx"],"names":["useMemo","Children","useState","useCallback","useContext","useEffect","cancelAnimation","useAnimatedReaction","useAnimatedRef","useAnimatedScrollHandler","useSharedValue","withDelay","withTiming","interpolate","Extrapolate","runOnJS","runOnUI","useDerivedValue","useDeepCompareMemo","Context","TabNameContext","IS_IOS","ONE_FRAME_MS","scrollToImpl","useContainerRef","useAnimatedDynamicRefs","map","setMap","setRef","key","ref","useTabProps","children","tabType","options","tabOptions","Map","forEach","element","index","type","Error","name","props","has","set","optionEntries","Array","from","entries","optionKeys","keys","memoizedOptions","memoizedTabNames","useTabsContext","c","useTabNameContext","useCollapsibleStyle","headerHeight","tabBarHeight","containerHeight","width","containerHeightVal","tabBarHeightVal","headerHeightVal","useConvertAnimatedToValue","style","contentContainerStyle","minHeight","paddingTop","progressViewOffset","useUpdateScrollViewContentSize","tabNames","contentHeights","setContentHeights","height","tabIndex","value","indexOf","scrollContentSizeChange","_","h","useChainCallback","fns","callAll","args","fn","useScroller","contentInset","scroller","x","y","animated","_debugKey","useScrollHandlerY","accDiffClamp","focusedTab","snapThreshold","revealHeaderOnScroll","refMap","scrollYCurrent","scrollY","isScrolling","isGliding","oldAccScrollY","accScrollY","offset","headerScrollDistance","isSnapping","snappingTo","enabled","enable","toggle","afterDrag","findIndex","n","scrollTo","onMomentumEnd","undefined","contentHeight","Number","MAX_VALUE","scrollHandler","onScroll","event","contentOffset","clampMax","CLAMP","delta","nextValue","Math","min","max","duration","onBeginDrag","onEndDrag","isFinished","onMomentumBegin","sync","nextPosition","focusedScrollY","tabScrollY","areEqual","currIsOnTop","focusedIsOnTop","hasGap","useSharedAnimatedRef","outerRef","current","useAfterMountEffect","effect","didExecute","setDidExecute","timeout","setTimeout","clearTimeout","animatedValue","setValue","animValue","useHeaderMeasurements","headerTranslateY","top","useFocusedTab","focusedTabValue","useAnimatedTabIndex","indexDecimal"],"mappings":"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","sourcesContent":["import {\n  useMemo,\n  Children,\n  useState,\n  useCallback,\n  useContext,\n  MutableRefObject,\n  useEffect,\n} from 'react'\nimport { ContainerRef, RefComponent } from 'react-native-collapsible-tab-view'\nimport Animated, {\n  cancelAnimation,\n  useAnimatedReaction,\n  useAnimatedRef,\n  useAnimatedScrollHandler,\n  useSharedValue,\n  withDelay,\n  withTiming,\n  interpolate,\n  Extrapolate,\n  runOnJS,\n  runOnUI,\n  useDerivedValue,\n} from 'react-native-reanimated'\nimport { useDeepCompareMemo } from 'use-deep-compare'\n\nimport { Context, TabNameContext } from './Context'\nimport { IS_IOS, ONE_FRAME_MS, scrollToImpl } from './helpers'\nimport {\n  CollapsibleStyle,\n  ContextType,\n  TabName,\n  TabReactElement,\n  TabsWithProps,\n  Ref,\n} from './types'\n\nexport function useContainerRef() {\n  return useAnimatedRef<ContainerRef>()\n}\n\nexport function useAnimatedDynamicRefs(): [\n  ContextType['refMap'],\n  ContextType['setRef']\n] {\n  const [map, setMap] = useState<ContextType['refMap']>({})\n  const setRef = useCallback(function <T extends RefComponent>(\n    key: TabName,\n    ref: React.RefObject<T>\n  ) {\n    setMap((map) => ({ ...map, [key]: ref }))\n    return ref\n  },\n  [])\n\n  return [map, setRef]\n}\n\nexport function useTabProps<T extends TabName>(\n  children: TabReactElement<T>[] | TabReactElement<T>,\n  tabType: Function\n): [TabsWithProps<T>, T[]] {\n  const options = useMemo(() => {\n    const tabOptions: TabsWithProps<T> = new Map()\n    if (children) {\n      Children.forEach(children, (element, index) => {\n        if (!element) return\n\n        if (element.type !== tabType)\n          throw new Error(\n            'Container children must be wrapped in a <Tabs.Tab ... /> component'\n          )\n\n        // make sure children is excluded otherwise our props will mutate too much\n        const { name, children, ...options } = element.props\n        if (tabOptions.has(name))\n          throw new Error(`Tab names must be unique, ${name} already exists`)\n\n        tabOptions.set(name, {\n          index,\n          name,\n          ...options,\n        })\n      })\n    }\n    return tabOptions\n  }, [children, tabType])\n  const optionEntries = Array.from(options.entries())\n  const optionKeys = Array.from(options.keys())\n  const memoizedOptions = useDeepCompareMemo(() => options, [optionEntries])\n  const memoizedTabNames = useDeepCompareMemo(() => optionKeys, [optionKeys])\n  return [memoizedOptions, memoizedTabNames]\n}\n\n/**\n * Hook exposing some useful variables.\n *\n * ```tsx\n * const { focusedTab, ...rest } = useTabsContext()\n * ```\n */\nexport function useTabsContext(): ContextType<TabName> {\n  const c = useContext(Context)\n  if (!c) throw new Error('useTabsContext must be inside a Tabs.Container')\n  return c\n}\n\n/**\n * Access the parent tab screen from any deep component.\n *\n * ```tsx\n * const tabName = useTabNameContext()\n * ```\n */\nexport function useTabNameContext(): TabName {\n  const c = useContext(TabNameContext)\n  if (!c) throw new Error('useTabNameContext must be inside a TabNameContext')\n  return c\n}\n\n/**\n * Hook to access some key styles that make the whole thing work.\n *\n * You can use this to get the progessViewOffset and pass to the refresh control of scroll view.\n */\nexport function useCollapsibleStyle(): CollapsibleStyle {\n  const {\n    headerHeight,\n    tabBarHeight,\n    containerHeight,\n    width,\n  } = useTabsContext()\n  const [containerHeightVal, tabBarHeightVal, headerHeightVal] = [\n    useConvertAnimatedToValue(containerHeight),\n    useConvertAnimatedToValue(tabBarHeight),\n    useConvertAnimatedToValue(headerHeight),\n  ]\n  return useMemo(\n    () => ({\n      style: { width },\n      contentContainerStyle: {\n        minHeight: IS_IOS\n          ? (containerHeightVal || 0) - (tabBarHeightVal || 0)\n          : (containerHeightVal || 0) + (headerHeightVal || 0),\n        paddingTop: IS_IOS\n          ? 0\n          : (headerHeightVal || 0) + (tabBarHeightVal || 0),\n      },\n      progressViewOffset: (headerHeightVal || 0) + (tabBarHeightVal || 0),\n    }),\n    [containerHeightVal, headerHeightVal, tabBarHeightVal, width]\n  )\n}\n\nexport function useUpdateScrollViewContentSize({ name }: { name: TabName }) {\n  const { tabNames, contentHeights } = useTabsContext()\n  const setContentHeights = useCallback(\n    (name: TabName, height: number) => {\n      const tabIndex = tabNames.value.indexOf(name)\n      contentHeights.value[tabIndex] = height\n      contentHeights.value = [...contentHeights.value]\n    },\n    [contentHeights, tabNames]\n  )\n\n  const scrollContentSizeChange = useCallback(\n    (_: number, h: number) => {\n      runOnUI(setContentHeights)(name, h)\n    },\n    [setContentHeights, name]\n  )\n\n  return scrollContentSizeChange\n}\n\n/**\n * Allows specifying multiple functions to be called in a sequence with the same parameters\n * Useful because we handle some events and need to pass them forward so that the caller can handle them as well\n * @param fns array of functions to call\n * @returns a function that once called will call all passed functions\n */\nexport function useChainCallback(fns: (Function | undefined)[]) {\n  const callAll = useCallback(\n    (...args: unknown[]) => {\n      fns.forEach((fn) => {\n        if (typeof fn === 'function') {\n          fn(...args)\n        }\n      })\n    },\n    [fns]\n  )\n  return callAll\n}\n\nexport function useScroller<T extends RefComponent>() {\n  const { contentInset } = useTabsContext()\n\n  const scroller = useCallback(\n    (\n      ref: Ref<T> | undefined,\n      x: number,\n      y: number,\n      animated: boolean,\n      _debugKey: string\n    ) => {\n      'worklet'\n      if (!ref) return\n      // console.log(`${_debugKey}, y: ${y}, y adjusted: ${y - contentInset}`)\n      scrollToImpl(ref, x, y - contentInset.value, animated)\n    },\n    [contentInset]\n  )\n\n  return scroller\n}\n\nexport const useScrollHandlerY = (name: TabName) => {\n  const {\n    accDiffClamp,\n    focusedTab,\n    snapThreshold,\n    revealHeaderOnScroll,\n    refMap,\n    tabNames,\n    index,\n    headerHeight,\n    contentInset,\n    containerHeight,\n    scrollYCurrent,\n    scrollY,\n    isScrolling,\n    isGliding,\n    oldAccScrollY,\n    accScrollY,\n    offset,\n    headerScrollDistance,\n    isSnapping,\n    snappingTo,\n    contentHeights,\n  } = useTabsContext()\n\n  const enabled = useSharedValue(false)\n\n  const enable = useCallback(\n    (toggle: boolean) => {\n      enabled.value = toggle\n    },\n    [enabled]\n  )\n\n  /**\n   * Helper value to track if user is dragging on iOS, because iOS calls\n   * onMomentumEnd only after a vigorous swipe. If the user has finished the\n   * drag, but the onMomentumEnd has never triggered, we need to manually\n   * call it to sync the scenes.\n   */\n  const afterDrag = useSharedValue(0)\n\n  const tabIndex = useMemo(() => tabNames.value.findIndex((n) => n === name), [\n    tabNames,\n    name,\n  ])\n\n  const scrollTo = useScroller()\n\n  const onMomentumEnd = () => {\n    'worklet'\n    if (!enabled.value) return\n\n    if (typeof snapThreshold === 'number') {\n      if (revealHeaderOnScroll) {\n        if (accDiffClamp.value > 0) {\n          if (\n            scrollYCurrent.value >\n            headerScrollDistance.value * snapThreshold\n          ) {\n            if (\n              accDiffClamp.value <=\n              headerScrollDistance.value * snapThreshold\n            ) {\n              // snap down\n              isSnapping.value = true\n              accDiffClamp.value = withTiming(0, undefined, () => {\n                isSnapping.value = false\n              })\n            } else if (accDiffClamp.value < headerScrollDistance.value) {\n              // snap up\n              isSnapping.value = true\n              accDiffClamp.value = withTiming(\n                headerScrollDistance.value,\n                undefined,\n                () => {\n                  isSnapping.value = false\n                }\n              )\n\n              if (scrollYCurrent.value < headerScrollDistance.value) {\n                scrollTo(\n                  refMap[name],\n                  0,\n                  headerScrollDistance.value,\n                  true,\n                  `[${name}] sticky snap up`\n                )\n              }\n            }\n          } else {\n            isSnapping.value = true\n            accDiffClamp.value = withTiming(0, undefined, () => {\n              isSnapping.value = false\n            })\n          }\n        }\n      } else {\n        if (\n          scrollYCurrent.value <=\n          headerScrollDistance.value * snapThreshold\n        ) {\n          // snap down\n          snappingTo.value = 0\n          scrollTo(refMap[name], 0, 0, true, `[${name}] snap down`)\n        } else if (scrollYCurrent.value <= headerScrollDistance.value) {\n          // snap up\n          snappingTo.value = headerScrollDistance.value\n          scrollTo(\n            refMap[name],\n            0,\n            headerScrollDistance.value,\n            true,\n            `[${name}] snap up`\n          )\n        }\n        isSnapping.value = false\n      }\n    }\n    isGliding.value = false\n  }\n\n  const contentHeight = useDerivedValue(() => {\n    const tabIndex = tabNames.value.indexOf(name)\n    return contentHeights.value[tabIndex] || Number.MAX_VALUE\n  }, [])\n\n  const scrollHandler = useAnimatedScrollHandler(\n    {\n      onScroll: (event) => {\n        if (!enabled.value) return\n\n        if (focusedTab.value === name) {\n          if (IS_IOS) {\n            let { y } = event.contentOffset\n            // normalize the value so it starts at 0\n            y = y + contentInset.value\n            const clampMax =\n              contentHeight.value -\n              (containerHeight.value || 0) +\n              contentInset.value\n            // make sure the y value is clamped to the scrollable size (clamps overscrolling)\n            scrollYCurrent.value = interpolate(\n              y,\n              [0, clampMax],\n              [0, clampMax],\n              Extrapolate.CLAMP\n            )\n          } else {\n            const { y } = event.contentOffset\n            scrollYCurrent.value = y\n          }\n\n          scrollY.value[index.value] = scrollYCurrent.value\n          oldAccScrollY.value = accScrollY.value\n          accScrollY.value = scrollY.value[index.value] + offset.value\n\n          if (!isSnapping.value && revealHeaderOnScroll) {\n            const delta = accScrollY.value - oldAccScrollY.value\n            const nextValue = accDiffClamp.value + delta\n            if (delta > 0) {\n              // scrolling down\n              accDiffClamp.value = Math.min(\n                headerScrollDistance.value,\n                nextValue\n              )\n            } else if (delta < 0) {\n              // scrolling up\n              accDiffClamp.value = Math.max(0, nextValue)\n            }\n          }\n\n          isScrolling.value = 1\n\n          // cancel the animation that is setting this back to 0 if we're still scrolling\n          cancelAnimation(isScrolling)\n\n          // set it back to 0 after a few frames without active scrolling\n          isScrolling.value = withDelay(\n            ONE_FRAME_MS * 3,\n            withTiming(0, { duration: 0 })\n          )\n        }\n      },\n      onBeginDrag: () => {\n        if (!enabled.value) return\n\n        // ensure the header stops snapping\n        cancelAnimation(accDiffClamp)\n\n        isSnapping.value = false\n        isScrolling.value = 0\n        isGliding.value = false\n\n        if (IS_IOS) cancelAnimation(afterDrag)\n      },\n      onEndDrag: () => {\n        if (!enabled.value) return\n\n        isGliding.value = true\n\n        if (IS_IOS) {\n          // we delay this by one frame so that onMomentumBegin may fire on iOS\n          afterDrag.value = withDelay(\n            ONE_FRAME_MS,\n            withTiming(0, { duration: 0 }, (isFinished) => {\n              // if the animation is finished, the onMomentumBegin has\n              // never started, so we need to manually trigger the onMomentumEnd\n              // to make sure we snap\n              if (isFinished) {\n                isGliding.value = false\n                onMomentumEnd()\n              }\n            })\n          )\n        }\n      },\n      onMomentumBegin: () => {\n        if (!enabled.value) return\n\n        if (IS_IOS) {\n          cancelAnimation(afterDrag)\n        }\n      },\n      onMomentumEnd,\n    },\n    [\n      refMap,\n      name,\n      revealHeaderOnScroll,\n      containerHeight,\n      contentInset,\n      snapThreshold,\n      enabled,\n      scrollTo,\n    ]\n  )\n\n  // sync unfocused scenes\n  useAnimatedReaction(\n    () => {\n      return (\n        !isSnapping.value &&\n        !isScrolling.value &&\n        !isGliding.value &&\n        enabled.value\n      )\n    },\n    (sync) => {\n      if (sync && focusedTab.value !== name) {\n        let nextPosition = null\n        const focusedScrollY = scrollY.value[index.value]\n        const tabScrollY = scrollY.value[tabIndex]\n        const areEqual = focusedScrollY === tabScrollY\n\n        if (!areEqual) {\n          const currIsOnTop = tabScrollY <= headerScrollDistance.value + 1\n          const focusedIsOnTop =\n            focusedScrollY <= headerScrollDistance.value + 1\n\n          if (revealHeaderOnScroll) {\n            const hasGap = accDiffClamp.value > tabScrollY\n            if (hasGap || currIsOnTop) {\n              nextPosition = accDiffClamp.value\n            }\n          } else if (typeof snapThreshold === 'number') {\n            if (focusedIsOnTop) {\n              nextPosition = snappingTo.value\n            } else if (currIsOnTop) {\n              nextPosition = headerHeight.value || 0\n            }\n          } else if (currIsOnTop || focusedIsOnTop) {\n            nextPosition = Math.min(focusedScrollY, headerScrollDistance.value)\n          }\n        }\n\n        if (nextPosition !== null) {\n          scrollY.value[tabIndex] = nextPosition\n          scrollTo(refMap[name], 0, nextPosition, false, `[${name}] sync pane`)\n        }\n      }\n    },\n    [revealHeaderOnScroll, refMap, snapThreshold, tabIndex, enabled, scrollTo]\n  )\n\n  return { scrollHandler, enable }\n}\n\ntype ForwardRefType<T> =\n  | ((instance: T | null) => void)\n  | MutableRefObject<T | null>\n  | null\n\n/**\n * Magic hook that creates a multicast ref. Useful so that we can both capture the ref, and forward it to callers.\n * Accepts a parameter for an outer ref that will also be updated to the same ref\n * @param outerRef the outer ref that needs to be updated\n * @returns an animated ref\n */\nexport function useSharedAnimatedRef<T extends RefComponent>(\n  outerRef: ForwardRefType<T>\n) {\n  const ref = useAnimatedRef<T>()\n\n  // this executes on every render\n  useEffect(() => {\n    if (!outerRef) {\n      return\n    }\n    if (typeof outerRef === 'function') {\n      outerRef(ref.current)\n    } else {\n      outerRef.current = ref.current\n    }\n  })\n\n  return ref\n}\n\nexport function useAfterMountEffect(effect: React.EffectCallback) {\n  const [didExecute, setDidExecute] = useState(false)\n  useEffect(() => {\n    if (didExecute) return\n\n    const timeout = setTimeout(() => {\n      effect()\n      setDidExecute(true)\n    }, 0)\n    return () => {\n      clearTimeout(timeout)\n    }\n  }, [didExecute, effect])\n}\n\nexport function useConvertAnimatedToValue<T>(\n  animatedValue: Animated.SharedValue<T>\n) {\n  const [value, setValue] = useState(animatedValue.value)\n\n  useAnimatedReaction(\n    () => {\n      return animatedValue.value\n    },\n    (animValue) => {\n      if (animValue !== value) {\n        runOnJS(setValue)(animValue)\n      }\n    },\n    [value]\n  )\n\n  return value\n}\n\ninterface HeaderMeasurements {\n  /**\n   * Animated value that represents the current Y translation of the header\n   */\n  top: Animated.SharedValue<number>\n  /**\n   * The height of the header\n   */\n  height: number\n}\n\nexport function useHeaderMeasurements(): HeaderMeasurements {\n  const { headerTranslateY, headerHeight } = useTabsContext()\n  return {\n    top: headerTranslateY,\n    height: headerHeight.value || 0,\n  }\n}\n\n/**\n * Returns the currently focused tab name\n */\nexport function useFocusedTab() {\n  const { focusedTab } = useTabsContext()\n  const focusedTabValue = useConvertAnimatedToValue(focusedTab)\n  return focusedTabValue\n}\n\n/**\n * Returns an animated value representing the current tab index, as a floating point number\n */\nexport function useAnimatedTabIndex() {\n  const { indexDecimal } = useTabsContext()\n  return indexDecimal\n}\n"]}